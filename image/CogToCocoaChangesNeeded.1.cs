'From Squeak4.1 of 1 October 2010 [latest update: #8325] on 23 December 2010 at 8:29:48 am'!!CCodeGenerator methodsFor: 'public' stamp: 'EstebanLorenzano 12/21/2010 20:50'!storeHeaderOnFile: fileName bytesPerWord: bytesPerWord	"Store C header code for this interpreter on the given file."	| aStream |	aStream := CrLfFileStream forceNewFileNamed: fileName.	aStream ifNil: [Error signal: 'Could not open C header file: ', fileName].	aStream		nextPutAll: '/* ';		nextPutAll: VMMaker headerNotice;		nextPutAll: ' */'; cr; cr.	self writeDefineBytesPerWord: bytesPerWord on: aStream.	self writeDefineMemoryAccessInImageOn: aStream.	self writeDefaultMacrosOn: aStream.	aStream close! !!CCodeGenerator methodsFor: 'public' stamp: 'EstebanLorenzano 12/21/2010 20:48'!writeDefaultMacrosOn: aStream	"Write macros to provide default implementations of certain functions used by	the interpreter. If not previously defined in config.h they will be defined here.	The definitions will be available to any module that includes sqMemoryAccess.h.	The default macros are chosen for backward compatibility with existing platform	support code."	aStream cr;		nextPutAll: '#ifndef allocateMemoryMinimumImageFileHeaderSize'; cr;		nextPutAll: ' /* Called by Interpreter>>allocateMemory:minimum:imageFile:headerSize: */'; cr;		nextPutAll: ' #define allocateMemoryMinimumImageFileHeaderSize(',						'heapSize, minimumMemory, fileStream, headerSize) \'; cr;		nextPutAll: '    sqAllocateMemory(minimumMemory, heapSize)'; cr;		nextPutAll: '#endif'; cr; cr;		nextPutAll: '#ifndef sqImageFileReadEntireImage'; cr;		nextPutAll: ' /* Called by Interpreter>>sqImage:read:size:length: */'; cr;		nextPutAll: ' #define sqImageFileReadEntireImage(memoryAddress, fileStream, ',						'elementSize,  length) \'; cr;		nextPutAll: '    sqImageFileRead(memoryAddress, fileStream, elementSize,  length)'; cr;		nextPutAll: '#endif'; cr; cr! !!CCodeGenerator methodsFor: 'public' stamp: 'EstebanLorenzano 12/21/2010 20:49'!writeDefineBytesPerWord: bytesPerWord on: aStream	aStream		nextPutAll: '#define SQ_VI_BYTES_PER_WORD ';		print: bytesPerWord;		cr! !!CCodeGenerator methodsFor: 'public' stamp: 'EstebanLorenzano 12/21/2010 20:49'!writeDefineMemoryAccessInImageOn: aStream	"If MemoryAccess is present in the image, then define MEMORY_ACCESS_IN_IMAGE as	a C preprocessor macro. When MEMORY_ACCESS_IN_IMAGE is defined, the traditional	C preprocessor macros for low level memory access are ignored and will be replaced	by directly translated (and inlined) SLANG versions of the same. This enables visibility	of the memory access functions for debuggers and profilers."	(Smalltalk classNamed: #MemoryAccess)		ifNotNilDo: [:ma | ma isEnabled			ifTrue: [aStream nextPutAll: '#define MEMORY_ACCESS_IN_IMAGE 1'; cr]]! !!Interpreter methodsFor: 'image save/restore' stamp: 'EstebanLorenzano 12/21/2010 23:11'!allocateMemory: heapSize minimum: minimumMemory imageFile: fileStream headerSize: headerSize	"Translate to C function call with (case sensitive) camelCase. The purpose of this	method is to document the translation.	The default implementation is sqAllocateMemory(minimumMemory, heapSize). This may	be redefined to make use of the image file and header size parameters for efficient	implementation with mmap().	See CCodeGenerator>>writeDefaultMacrosOn: which specifies a default implementation."	self inline: true.	self returnTypeC: 'char *'.	self var: #fileStream type: 'sqImageFile'.	^ self		allocateMemory: heapSize		Minimum: minimumMemory		ImageFile: fileStream		HeaderSize: headerSize! !!Interpreter methodsFor: 'image save/restore' stamp: 'EstebanLorenzano 12/21/2010 23:10'!readImageFromFile: f HeapSize: desiredHeapSize StartingAt: imageOffset	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr minimumMemory memStart bytesRead bytesToShift heapSize |	<var: #f type: 'sqImageFile '>	<var: #headerStart type: 'squeakFileOffsetType '>	<var: #dataSize type: 'size_t '>	<var: #imageOffset type: 'squeakFileOffsetType '>	metaclassSizeBytes := 6 * BytesPerWord.	"guess (Metaclass instSize * BPW)"	swapBytes := self checkImageVersionFrom: f startingAt: imageOffset.	headerStart := (self sqImageFilePosition: f) - BytesPerWord.  "record header start position"	headerSize			:= self getLongFromFile: f swap: swapBytes.	dataSize				:= self getLongFromFile: f swap: swapBytes.	oldBaseAddr			:= self getLongFromFile: f swap: swapBytes.	specialObjectsOop	:= self getLongFromFile: f swap: swapBytes.	lastHash			:= self getLongFromFile: f swap: swapBytes.	savedWindowSize	:= self getLongFromFile: f swap: swapBytes.	fullScreenFlag		:= self getLongFromFile: f swap: swapBytes.	extraVMMemory		:= self getLongFromFile: f swap: swapBytes.	lastHash = 0 ifTrue: [		"lastHash wasn't stored (e.g. by the cloner); use 999 as the seed"		lastHash := 999].	"decrease Squeak object heap to leave extra memory for the VM"	heapSize := self cCode: 'reserveExtraCHeapBytes(desiredHeapSize, extraVMMemory)'.	"compare memory requirements with availability".	minimumMemory := dataSize + 100000.  "need at least 100K of breathing room"	heapSize < minimumMemory ifTrue: [		self insufficientMemorySpecifiedError].	"allocate a contiguous block of memory for the Squeak heap"	"memory := self cCode: 'sqAllocateMemory(minimumMemory, heapSize)'."	memory := (self		allocateMemory: heapSize		minimum: minimumMemory		imageFile: f		headerSize: headerSize).	memory = nil ifTrue: [self insufficientMemoryAvailableError].	memStart := self startOfMemory.	self setMemoryLimit: (memStart + heapSize) - 24.  "decrease memoryLimit a tad for safety"	self setEndOfMemory: memStart + dataSize.	"position file after the header"	self sqImageFile: f Seek: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead := self cCode: 'sqImageFileRead(pointerForOop(memory), sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize ifTrue: [self unableToReadImageError].	swapBytes ifTrue: [self reverseBytesInImage].	"compute difference between old and new memory base addresses"	bytesToShift := memStart - oldBaseAddr.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	^ dataSize! !!Interpreter methodsFor: 'I/O primitives' stamp: 'John M McIntosh 7/8/2010 11:46'!primitiveGetNextEvent	"Primitive. Return the next input event from the VM event queue."	| evtBuf arg value eventTypeIs |	<var: #evtBuf declareC:'int evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }'>	self cCode:'' inSmalltalk:[evtBuf := CArrayAccessor on: (IntegerArray new: 8)].	arg := self stackTop.	((self isArray: arg) and:[(self slotSizeOf: arg) = 8])  ifFalse:[^self primitiveFail].	self ioGetNextEvent: (self cCoerce: evtBuf to: 'sqInputEvent*').	successFlag ifFalse:[^nil].	"Event type"	eventTypeIs := evtBuf at: 0.	self storeInteger: 0 ofObject: arg withValue: (evtBuf at: 0).	successFlag ifFalse:[^nil].	"Event is Complex, assume evtBuf is populated correctly and return"	eventTypeIs = 6 ifTrue: 		[1 to: 7 do: [:i |			value := evtBuf at: i.			self storePointer: i ofObject: arg withValue: value]]	ifFalse: [	"Event time stamp"	self storeInteger: 1 ofObject: arg withValue: ((evtBuf at: 1) bitAnd: MillisecondClockMask).	successFlag ifFalse:[^nil].	"Event arguments"	2 to: 7 do:[:i|		value := evtBuf at: i.		(self isIntegerValue: value)			ifTrue:[self storeInteger: i ofObject: arg withValue: value]			ifFalse:["Need to remap because allocation may cause GC"				self pushRemappableOop: arg.				value := self positive32BitIntegerFor: value.				arg := self popRemappableOop.				self storePointer: i ofObject: arg withValue: value]]].	successFlag ifFalse:[^nil].	self pop: 1.! !!InterpreterPrimitives methodsFor: 'I/O primitives' stamp: 'EstebanLorenzano 12/21/2010 00:55'!primitiveGetNextEvent	"Primitive. Return the next input event from the VM event queue."	| evtBuf arg value eventTypeIs |	<var: #evtBuf declareC:'int evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }'>	self cCode:'' inSmalltalk:[evtBuf := CArrayAccessor on: (IntegerArray new: 8)].	arg := self stackTop.	((self isArray: arg) and:[(self slotSizeOf: arg) = 8])  ifFalse:[^self primitiveFail].	self ioGetNextEvent: (self cCoerce: evtBuf to: 'sqInputEvent*').	self successful ifFalse:[^nil].	"Event type"	eventTypeIs := evtBuf at: 0.	self storeInteger: 0 ofObject: arg withValue: (evtBuf at: 0).	self successful ifFalse:[^nil].	"Event is Complex, assume evtBuf is populated correctly and return"	eventTypeIs = 6 ifTrue: 		[1 to: 7 do: [:i |			value := evtBuf at: i.			self storePointer: i ofObject: arg withValue: value]]	ifFalse: [			"Event time stamp"	self storeInteger: 1 ofObject: arg withValue: ((evtBuf at: 1) bitAnd: MillisecondClockMask).	self successful ifFalse:[^nil].	"Event arguments"	2 to: 7 do:[:i|		value := evtBuf at: i.		(self isIntegerValue: value)			ifTrue:[self storeInteger: i ofObject: arg withValue: value]			ifFalse:[value := self positive32BitIntegerFor: value.				self storePointer: i ofObject: arg withValue: value]]].	self successful ifFalse:[^nil].	self pop: 1! !!InterpreterPrimitives methodsFor: 'as yet unclassified' stamp: 'EstebanLorenzano 12/21/2010 23:13'!allocateMemory: heapSize minimum: minimumMemory imageFile: fileStream headerSize: headerSize	"Translate to C function call with (case sensitive) camelCase. The purpose of this	method is to document the translation.	The default implementation is sqAllocateMemory(minimumMemory, heapSize). This may	be redefined to make use of the image file and header size parameters for efficient	implementation with mmap().	See CCodeGenerator>>writeDefaultMacrosOn: which specifies a default implementation."	self inline: true.	self returnTypeC: 'char *'.	self var: #fileStream type: 'sqImageFile'.	^ self		allocateMemory: heapSize		Minimum: minimumMemory		ImageFile: fileStream		HeaderSize: headerSize! !!StackInterpreter methodsFor: 'image save/restore' stamp: 'EstebanLorenzano 12/21/2010 23:08'!readImageFromFile: f HeapSize: desiredHeapSize StartingAt: imageOffset	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr hdrNumStackPages	  minimumMemory memStart bytesRead bytesToShift heapSize hdrEdenBytes	  headerFlags hdrMaxExtSemTabSize |	<var: #f type: 'sqImageFile '>	<var: #memStart type: 'usqInt'>	<var: #headerStart type: 'squeakFileOffsetType '>	<var: #dataSize type: 'size_t '>	<var: #imageOffset type: 'squeakFileOffsetType '>	metaclassSizeBytes := 6 * BytesPerWord.	"guess (Metaclass instSize * BPW)"	swapBytes := self checkImageVersionFrom: f startingAt: imageOffset.	headerStart := (self sqImageFilePosition: f) - BytesPerWord.  "record header start position"	headerSize			:= self getLongFromFile: f swap: swapBytes.	dataSize			:= self getLongFromFile: f swap: swapBytes.	oldBaseAddr		:= self getLongFromFile: f swap: swapBytes.	objectMemory specialObjectsOop: (self getLongFromFile: f swap: swapBytes).	objectMemory lastHash: (self getLongFromFile: f swap: swapBytes). "N.B.  not used."	savedWindowSize	:= self getLongFromFile: f swap: swapBytes.	headerFlags			:= self getLongFromFile: f swap: swapBytes.	self setImageHeaderFlagsFrom: headerFlags.	extraVMMemory		:= self getLongFromFile: f swap: swapBytes.	hdrNumStackPages	:= self getShortFromFile: f swap: swapBytes.	"4 stack pages is small.  Should be able to run with as few as	 three. 4 should be comfortable but slow.  8 is a reasonable	 default.  Can be changed via vmParameterAt: 43 put: n.	 Can be set as a preference (Info.plist, VM.ini, command line etc).	 If desiredNumStackPages is already non-zero then it has been	 set as a preference.  Ignore (but preserve) the header's default."	numStackPages := desiredNumStackPages ~= 0						ifTrue: [desiredNumStackPages]						ifFalse: [hdrNumStackPages = 0									ifTrue: [self defaultNumStackPages]									ifFalse: [hdrNumStackPages]].	desiredNumStackPages := hdrNumStackPages.	"pad to word boundary.  This slot can be used for anything else that will fit in 16 bits.	 Preserve it to be polite to images run on Cog."	theUnknownShort	:= self getShortFromFile: f swap: swapBytes.	hdrEdenBytes		:= self getLongFromFile: f swap: swapBytes.	objectMemory edenBytes: (desiredEdenBytes ~= 0						ifTrue: [desiredEdenBytes]						ifFalse:							[hdrEdenBytes = 0									ifTrue: [objectMemory defaultEdenBytes]									ifFalse: [hdrEdenBytes]]).	desiredEdenBytes := hdrEdenBytes.	hdrMaxExtSemTabSize := self getShortFromFile: f swap: swapBytes.	hdrMaxExtSemTabSize ~= 0 ifTrue:		[self setMaxExtSemSizeTo: hdrMaxExtSemTabSize].	"decrease Squeak object heap to leave extra memory for the VM"	heapSize := self cCode: 'reserveExtraCHeapBytes(desiredHeapSize, extraVMMemory)'.	"compare memory requirements with availability".	minimumMemory := dataSize + objectMemory edenBytes + self interpreterAllocationReserveBytes.	heapSize < minimumMemory ifTrue:		[self insufficientMemorySpecifiedError].	"allocate a contiguous block of memory for the Squeak heap"	"objectMemory memory: (self cCode: 'sqAllocateMemory(minimumMemory, heapSize)')."	objectMemory memory: (self		allocateMemory: heapSize		minimum: minimumMemory		imageFile: f		headerSize: headerSize).	objectMemory memory = nil ifTrue: [self insufficientMemoryAvailableError].	memStart := objectMemory startOfMemory.	objectMemory setMemoryLimit: (memStart + heapSize) - 24.  "decrease memoryLimit a tad for safety"	objectMemory setEndOfMemory: memStart + dataSize.	"position file after the header"	self sqImageFile: f Seek: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead := self cCode: 'sqImageFileRead(pointerForOop(memory), sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize ifTrue: [self unableToReadImageError].	self ensureImageFormatIsUpToDate: swapBytes.	"compute difference between old and new memory base addresses"	bytesToShift := memStart - oldBaseAddr.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	^dataSize! !!CoInterpreter methodsFor: 'image save/restore' stamp: 'EstebanLorenzano 12/21/2010 23:10'!readImageFromFile: f HeapSize: desiredHeapSize StartingAt: imageOffset	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr	  minimumMemory heapSize bytesRead bytesToShift	  hdrNumStackPages hdrEdenBytes hdrCogCodeSize headerFlags hdrMaxExtSemTabSize |	<var: #f type: 'sqImageFile '>	<var: #memStart type: 'usqInt'>	<var: #desiredHeapSize type: 'usqInt'>	<var: #headerStart type: 'squeakFileOffsetType '>	<var: #dataSize type: 'size_t '>	<var: #imageOffset type: 'squeakFileOffsetType '>	metaclassSizeBytes := 6 * BytesPerWord.	"guess (Metaclass instSize * BPW)"	swapBytes := self checkImageVersionFrom: f startingAt: imageOffset.	headerStart := (self sqImageFilePosition: f) - BytesPerWord.  "record header start position"	headerSize			:= self getLongFromFile: f swap: swapBytes.	dataSize			:= self getLongFromFile: f swap: swapBytes.	oldBaseAddr		:= self getLongFromFile: f swap: swapBytes.	objectMemory specialObjectsOop: (self getLongFromFile: f swap: swapBytes).	objectMemory lastHash: (self getLongFromFile: f swap: swapBytes). "N.B.  not used."	savedWindowSize	:= self getLongFromFile: f swap: swapBytes.	headerFlags			:= self getLongFromFile: f swap: swapBytes.	self setImageHeaderFlagsFrom: headerFlags.	extraVMMemory		:= self getLongFromFile: f swap: swapBytes. "N.B.  not used."	hdrNumStackPages	:= self getShortFromFile: f swap: swapBytes.	"4 stack pages is small.  Should be able to run with as few as	 three. 4 should be comfortable but slow.  8 is a reasonable	 default.  Can be changed via vmParameterAt: 43 put: n.	 Can be set as a preference (Info.plist, VM.ini, command line etc).	 If desiredNumStackPages is already non-zero then it has been	 set as a preference.  Ignore (but preserve) the header's default."	numStackPages := desiredNumStackPages ~= 0						ifTrue: [desiredNumStackPages]						ifFalse: [hdrNumStackPages = 0									ifTrue: [self defaultNumStackPages]									ifFalse: [hdrNumStackPages]].	desiredNumStackPages := hdrNumStackPages.	"This slot holds the size of the native method zone in 1k units. (pad to word boundary)."	hdrCogCodeSize := (self getShortFromFile: f swap: swapBytes) * 1024.	cogCodeSize := desiredCogCodeSize ~= 0						ifTrue: [desiredCogCodeSize]						ifFalse:							[hdrCogCodeSize = 0									ifTrue: [self defaultCogCodeSize]									ifFalse: [hdrCogCodeSize]].	hdrEdenBytes		:= self getLongFromFile: f swap: swapBytes.	objectMemory edenBytes: (desiredEdenBytes ~= 0						ifTrue: [desiredEdenBytes]						ifFalse:							[hdrEdenBytes = 0									ifTrue: [objectMemory defaultEdenBytes]									ifFalse: [hdrEdenBytes]]).	desiredEdenBytes := hdrEdenBytes.	hdrMaxExtSemTabSize := self getShortFromFile: f swap: swapBytes.	hdrMaxExtSemTabSize ~= 0 ifTrue:		[self setMaxExtSemSizeTo: hdrMaxExtSemTabSize].	"compare memory requirements with availability"	minimumMemory := cogCodeSize "no need to include the stackZone; this is alloca'ed"						+ dataSize						+ objectMemory edenBytes						+ self interpreterAllocationReserveBytes.	heapSize             :=  cogCodeSize "no need to include the stackZone; this is alloca'ed"						+ desiredHeapSize						"+ edenBytes" "don't include edenBytes; this is part of the heap and so part of desiredHeapSize"						+ self interpreterAllocationReserveBytes.	heapSize < minimumMemory ifTrue:		[self insufficientMemorySpecifiedError].	"allocate a contiguous block of memory for the Squeak heap"	"N.B. If the platform needs to it will redefine this macro to make heapSize	 an in/out parameter and assign the ammount actually allocated into heapSize.	 See e.g. platforms/Mac OS/vm/sqPlatformSpecific.h.  (I *hate* this. eem 7/23/2009)"	"objectMemory memory: (self cCode: 'sqAllocateMemory(minimumMemory, heapSize)')."	objectMemory memory: (self		allocateMemory: heapSize		minimum: minimumMemory		imageFile: f		headerSize: headerSize).	objectMemory memory = nil ifTrue: [self insufficientMemoryAvailableError].	heapBase := objectMemory memory + cogCodeSize.	self assert: objectMemory startOfMemory = heapBase.	objectMemory setMemoryLimit: objectMemory memory + heapSize - 24.  "decrease memoryLimit a tad for safety"	objectMemory setEndOfMemory: heapBase + dataSize.	"position file after the header"	self sqImageFile: f Seek: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead := self cCode: 'sqImageFileRead(pointerForOop(heapBase), sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize ifTrue: [self unableToReadImageError].	self ensureImageFormatIsUpToDate: swapBytes.	"compute difference between old and new memory base addresses"	bytesToShift := heapBase - oldBaseAddr.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	self initializeCodeGenerator.	^dataSize! !!VMMaker class methodsFor: 'as yet unclassified' stamp: 'EstebanLorenzano 12/21/2010 20:50'!headerNotice"return a string to be put at the front of generated code files"	^String streamContents:[:strm|		strm nextPutAll: 'Automatically generated from Squeak on '.		strm nextPutAll: Time dateAndTimeNow printString.		strm cr.		strm nextPutAll: 'by VMMaker '.		strm nextPutAll: self  versionString.		strm cr]! !